{
  "api/Blackwood.Application.html": {
    "href": "api/Blackwood.Application.html",
    "title": "Class Application | Blackwood.IO",
    "summary": "Class Application Namespace Blackwood Assembly Blackwood.IO.dll This is a utility class to provide some information about the application. public static class Application Inheritance object Application Properties Name The application name. public static string Name { get; } Property Value string The application name."
  },
  "api/Blackwood.CacheItem-1.html": {
    "href": "api/Blackwood.CacheItem-1.html",
    "title": "Class CacheItem<itemType> | Blackwood.IO",
    "summary": "Class CacheItem<itemType> Namespace Blackwood Assembly Blackwood.IO.dll An item in the doubly linked list. public class CacheItem<itemType> Type Parameters itemType The type of item to cache. Inheritance object CacheItem<itemType> Fields key The value to cache public readonly itemType key Field Value itemType The type of item to cache."
  },
  "api/Blackwood.EmbeddedResources.html": {
    "href": "api/Blackwood.EmbeddedResources.html",
    "title": "Class EmbeddedResources | Blackwood.IO",
    "summary": "Class EmbeddedResources Namespace Blackwood Assembly Blackwood.IO.dll This is an interface to allow access to resources within a folder or archive public class EmbeddedResources : IFolderWrapper, IDisposable Inheritance object EmbeddedResources Implements IFolderWrapper IDisposable Constructors EmbeddedResources() Load resources from embedded in the assembly resources. public EmbeddedResources() EmbeddedResources(Assembly) Load resources from embedded in the assembly resources. public EmbeddedResources(Assembly a) Parameters a Assembly The assembly read resources from Methods Dispose() Performs any needed clean up public void Dispose() Exists(string) Determines whether the specified file exists. public bool Exists(string relativePath) Parameters relativePath string The name of file embedded in the assembly Returns bool true if the file exists embedded in the assembly, false otherwise Stream(string) This creates a stream for the given resources embedded in the assembly public Stream Stream(string relativePath) Parameters relativePath string The name of file embedded in the assembly Returns Stream null on error, otherwise a stream that can be used to access the file data"
  },
  "api/Blackwood.FS.html": {
    "href": "api/Blackwood.FS.html",
    "title": "Class FS | Blackwood.IO",
    "summary": "Class FS Namespace Blackwood Assembly Blackwood.IO.dll This class provides a variety of utilities such as the path's to key points, and process path strings. public static class FS Inheritance object FS Fields ExeFilePath The path to the executable. public static string ExeFilePath Field Value string The path to the executable. Properties AppDataPath The path to the application's data. public static string AppDataPath { get; } Property Value string The path to the application's data. AssemblyDirectory The path of the executing assembly. public static string AssemblyDirectory { get; } Property Value string The path of the executing assembly. Remarks https://stackoverflow.com/questions/52797/how-do-i-get-the-path-of-the-assembly-the-code-is-in CommonApplicationDataPath The path to the application's data. public static string CommonApplicationDataPath { get; } Property Value string The path to the application's data. Methods BuildNameToRelativePathXref(string, string) A helper to go from partial file name to the full file name. public static Dictionary<string, string> BuildNameToRelativePathXref(string path, string extension = \"json\") Parameters path string The path to search within extension string The file name extension (defualt is json) Returns Dictionary<string, string> The dictionary mapping the partial file names to the path RemoveBasePath(string, string) This is use to remove the base path from the full path. public static string RemoveBasePath(string basePath, string path) Parameters basePath string The path that should be removed path string The path that is to be modified Returns string The resulting path"
  },
  "api/Blackwood.FolderWrapper.html": {
    "href": "api/Blackwood.FolderWrapper.html",
    "title": "Class FolderWrapper | Blackwood.IO",
    "summary": "Class FolderWrapper Namespace Blackwood Assembly Blackwood.IO.dll This is a class to allow access to resources within a folder. It is a sibling to ZipWrapper that can access resources within a zip file public class FolderWrapper : IFolderWrapper, IDisposable Inheritance object FolderWrapper Implements IFolderWrapper IDisposable Constructors FolderWrapper(string) Creates an object that can access resources within a folder public FolderWrapper(string basePath) Parameters basePath string The basepath to the folder Methods Dispose() Dispose of any internal resources public void Dispose() Dispose(bool) Dispose of the binary stream protected virtual void Dispose(bool disposing) Parameters disposing bool Exists(string) Determines whether the specified file exists. public bool Exists(string relativePath) Parameters relativePath string The name of file within the wrapper Returns bool true if the file exists within the wrapper, false otherwise Stream(string) This creates a stream for the given resources within the folder public Stream Stream(string relativePath) Parameters relativePath string The name of file within the wrapper Returns Stream A stream that can be used to access the file"
  },
  "api/Blackwood.IFolderWrapper.html": {
    "href": "api/Blackwood.IFolderWrapper.html",
    "title": "Interface IFolderWrapper | Blackwood.IO",
    "summary": "Interface IFolderWrapper Namespace Blackwood Assembly Blackwood.IO.dll This is an interface to allow access to resources within a folder or archive public interface IFolderWrapper : IDisposable Inherited Members IDisposable.Dispose() Methods Exists(string) Determines whether the specified file exists. bool Exists(string relativePath) Parameters relativePath string The name of file within the wrapper Returns bool true if the file exists within the wrapper, false otherwise Stream(string) This creates a stream for the given resources within the container Stream Stream(string relativePath) Parameters relativePath string The name of file within the container Returns Stream A stream that can be used to access the file data"
  },
  "api/Blackwood.MRUCache-2.html": {
    "href": "api/Blackwood.MRUCache-2.html",
    "title": "Class MRUCache<keyType, valueType> | Blackwood.IO",
    "summary": "Class MRUCache<keyType, valueType> Namespace Blackwood Assembly Blackwood.IO.dll An associative Most-Recently-Used cache. The least recently used items are subject to being ejected. public class MRUCache<keyType, valueType> Type Parameters keyType The type of the key valueType The type of the item to cache Inheritance object MRUCache<keyType, valueType> Remarks A ring buffer is used track the oldest item for eviction. If the dictionary is allowed to grow too big, it becomes a botle neck Constructors MRUCache(int) Constructs the cache public MRUCache(int maxItems = 1024) Parameters maxItems int The maximum number of items to hold in the queue Fields head The most recently used item. protected CacheItem<keyType> head Field Value CacheItem<keyType> The cache-item, specialized for type of the key, to hold the recently used item. Properties this[keyType] This is used to fetch the cached items public valueType this[keyType key] { get; set; } Parameters key keyType The key used to associate with the item. Property Value valueType The associated value Methods Enumerate() Allow iteration over all of the items in the cache public IEnumerable<CacheItem<keyType>> Enumerate() Returns IEnumerable<CacheItem<keyType>> Each of the cache slots.. the slot is returned to allow managing the list"
  },
  "api/Blackwood.Text.html": {
    "href": "api/Blackwood.Text.html",
    "title": "Class Text | Blackwood.IO",
    "summary": "Class Text Namespace Blackwood Assembly Blackwood.IO.dll This class holds a variety of helper utilities to modify text. public static class Text Inheritance object Text Methods ReadAllLines(Stream) Load all of the text lines from the stream public static string ReadAllLines(Stream stream) Parameters stream Stream The text stream Returns string The text of the file SubstituteVars(string, IDictionary<string, object>) Substitute in the variable references with the values that are in the tableau. public static string SubstituteVars(string sourceText, IDictionary<string, object> tableau) Parameters sourceText string The original text string tableau IDictionary<string, object> The table of values for variables Returns string The potentially modified string Remarks This is not particularly effecient but it isn't intended to be used in an environment like that"
  },
  "api/Blackwood.Util.dWriteBackground.html": {
    "href": "api/Blackwood.Util.dWriteBackground.html",
    "title": "Delegate Util.dWriteBackground | Blackwood.IO",
    "summary": "Delegate Util.dWriteBackground Namespace Blackwood Assembly Blackwood.IO.dll This delegate will be called in the background to allow saving a file without causing the UI to experience an slowdown or stutter. public delegate void Util.dWriteBackground(FileStream stream) Parameters stream FileStream The file that was created in the background."
  },
  "api/Blackwood.Util.html": {
    "href": "api/Blackwood.Util.html",
    "title": "Class Util | Blackwood.IO",
    "summary": "Class Util Namespace Blackwood Assembly Blackwood.IO.dll This is a helper class to provide a variety of utility procedures. public static class Util Inheritance object Util Methods RunCommand(string, string, string) This is used to run the program or verb-based commands in the background. public static IAsyncEnumerable<string> RunCommand(string toRun = null, string verb = null, string arguments = null) Parameters toRun string The path to the executable or command to run. verb string The verb to use to run the program. arguments string The command line arguments Returns IAsyncEnumerable<string> An enumeration of the text lines that the process emitted Save(string, dWriteBackground) Saves the file to the given path. This is done in the background by first writing to a temporary file, then moving to the target. public static void Save(string path, Util.dWriteBackground writeBackground) Parameters path string The path to store the data. writeBackground Util.dWriteBackground The callback to populate the data in the file. Unzip(byte[]) Decompresses the array public static byte[] Unzip(byte[] zippedBuffer) Parameters zippedBuffer byte[] The buffer of compressed data Returns byte[] The decompressed data Zip(byte[], int, int) Compresses the array public static byte[] Zip(byte[] array, int offset, int count) Parameters array byte[] The array to compress offset int The offset in the array to start count int The number of bytes to compress Returns byte[] The compressed bytes"
  },
  "api/Blackwood.ZipWrapper.html": {
    "href": "api/Blackwood.ZipWrapper.html",
    "title": "Class ZipWrapper | Blackwood.IO",
    "summary": "Class ZipWrapper Namespace Blackwood Assembly Blackwood.IO.dll This is a class to allow access to resources within an archive. It is a sibling to FolderWrapper that can access resources within a folder public class ZipWrapper : IFolderWrapper, IDisposable Inheritance object ZipWrapper Implements IFolderWrapper IDisposable Constructors ZipWrapper(Stream) Creates an object that can access resources within an archive. public ZipWrapper(Stream stream) Parameters stream Stream The stream to the archive file ZipWrapper(string) Creates an object that can access resources within an archive. public ZipWrapper(string path) Parameters path string The path to the archive file Methods Dispose() Dispose of any internal resources. public void Dispose() Dispose(bool) Dispose of the archive. protected virtual void Dispose(bool disposing) Parameters disposing bool true, right? Exists(string) Determines whether the specified file exists. public bool Exists(string relativePath) Parameters relativePath string The name of file within the wrapper. Returns bool true if the file exists within the wrapper, false otherwise Retain() Increment the reference count for this object. Decrement the count using Dispose(). public void Retain() Stream(string) This creates a stream for the given resources within the container. public Stream Stream(string relativePath) Parameters relativePath string The name of file within the container Returns Stream null on error, otherwise a stream that can be used to access the file data"
  },
  "api/Blackwood.html": {
    "href": "api/Blackwood.html",
    "title": "Namespace Blackwood | Blackwood.IO",
    "summary": "Namespace Blackwood Classes Application This is a utility class to provide some information about the application. CacheItem<itemType> An item in the doubly linked list. EmbeddedResources This is an interface to allow access to resources within a folder or archive FS This class provides a variety of utilities such as the path's to key points, and process path strings. FolderWrapper This is a class to allow access to resources within a folder. It is a sibling to ZipWrapper that can access resources within a zip file MRUCache<keyType, valueType> An associative Most-Recently-Used cache. The least recently used items are subject to being ejected. Text This class holds a variety of helper utilities to modify text. Util This is a helper class to provide a variety of utility procedures. ZipWrapper This is a class to allow access to resources within an archive. It is a sibling to FolderWrapper that can access resources within a folder Interfaces IFolderWrapper This is an interface to allow access to resources within a folder or archive Delegates Util.dWriteBackground This delegate will be called in the background to allow saving a file without causing the UI to experience an slowdown or stutter."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Documentation | Blackwood.IO",
    "summary": "API Documentation This file summarizes the namespaces and classes in this assembly. Blackwood Namespace The Blackwood namespace is used to contain extra helper procedures and classes. Component Description Application A class to hold a Application name and path related utilities. CacheItem A class implementing a cache slot as part of the most-recently used cache. EmbeddedResources This is a class to allow access to resources within the resource area of an assembly. It is a sibling to ZipWrapper that can access resources within a zip file. FolderWrapper This is a class to allow access to resources within a folder. It is a sibling to ZipWrapper that can access resources within a zip file. FS A class to hold a file-system-related utilities. IFolderWrapper This is an interface to allow access to resources within a folder or archive. MRUCache A class implementing a most-recently used cache. Text A class to hold a text-related utilities. Util A class to hold a variety of helper utilities. ZipWrapper This is a class to allow access to resources within an archive. It is a sibling to FolderWrapper that can access resources within a folder."
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started with Blackwood.IO | Blackwood.IO",
    "summary": "Getting Started with Blackwood.IO This guide will help you get up and running with Blackwood.IO, a .NET library that provides utilities for file operations, caching, and system integration. Prerequisites .NET 8.0 or later - The library targets .NET 8.0+ Visual Studio 2022 (Windows) or VS Code with C# extension (cross-platform) Installation Using Package Manager Console Install-Package Blackwood.IO Using .NET CLI dotnet add package Blackwood.IO Using PackageReference Add the following to your .csproj file: <PackageReference Include=\"Blackwood.IO\" Version=\"2.0.0\" /> Quick Start 1. Basic File Operations using Blackwood; // Get application paths var appPaths = new AppPaths(); string dataPath = appPaths.GetDataPath(\"MyApplication\"); // Create a folder wrapper for file operations var folder = new FolderWrapper(dataPath); // Write a file with atomic operation string content = \"Hello, World!\"; folder.WriteAllText(\"greeting.txt\", content); // Read the file back string readContent = folder.ReadAllText(\"greeting.txt\"); Console.WriteLine(readContent); // Output: Hello, World! 2. Caching with MRU Cache using Blackwood; // Create an MRU cache with a maximum of 100 items var cache = new MRUCache<string, string>(100); // Add items to cache cache[\"user1\"] = \"John Doe\"; cache[\"user2\"] = \"Jane Smith\"; // Retrieve items string user1 = cache[\"user1\"]; // Returns \"John Doe\" // The cache automatically manages memory by removing least recently used items 3. Path Management Leverage the built-in path management to use standard paths instead of hardcoded ones for AppName: Get application name from assembly AppPaths: Get standard application paths (data, executable, etc.) using Blackwood; // Get application name and paths string applicationName = Application.Name; string dataPath = Application.AppDataPath; Console.WriteLine($\"Application: {applicationName}\"); Console.WriteLine($\"Data Path: {dataPath}\"); 4. Text Processing SubstituteVars: Variable substitution in text templates ReadAllLines: Enhanced text file reading with encoding support using Blackwood; // Substitute variables in text string template = \"Hello, {name}! Your score is {score}.\"; var variables = new Dictionary<string, object> { [\"name\"] = \"Alice\", [\"score\"] = 95 }; string result = SubstituteVars.Substitute(template, variables); Console.WriteLine(result); // Output: Hello, Alice! Your score is 95. Core Components File Operations FolderWrapper: Provides atomic file operations and background processing IFolderWrapper: Interface for folder operations (implemented by FolderWrapper and ZipWrapper) ZipWrapper: Access files within ZIP archives Caching MRUCache<TKey, TValue>: Most Recently Used cache with configurable capacity CacheItem<T>: Individual cache items with key-value pairs Common Use Cases Application Configuration using Blackwood; public class AppConfig { private readonly FolderWrapper _configFolder; public AppConfig() { var appPaths = new AppPaths(); var appName = new AppName(); string configPath = appPaths.GetConfigPath(appName.GetApplicationName()); _configFolder = new FolderWrapper(configPath); } public void SaveConfig(string configJson) { _configFolder.WriteAllText(\"appsettings.json\", configJson); } public string LoadConfig() { return _configFolder.ReadAllText(\"appsettings.json\"); } } Data Caching using Blackwood; public class DataService { private readonly MRUCache<string, object> _cache; public DataService() { _cache = new MRUCache<string, object>(1000); } public async Task<T> GetDataAsync<T>(string key, Func<Task<T>> dataLoader) { if (_cache.TryGetValue(key, out var cachedValue)) { return (T)cachedValue; } var data = await dataLoader(); _cache[key] = data; return data; } } Next Steps API Reference - Explore the complete API documentation"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction to Blackwood.IO | Blackwood.IO",
    "summary": "Introduction to Blackwood.IO Blackwood.IO is a .NET library providing utilities for file operations, caching, and system integration: File Operations: File handling with atomic operations and background processing Caching: In-memory caching with LRU (Least Recently Used) eviction policies Path Management: Path resolution and manipulation utilities Resource Management: Embedded resource handling and ZIP file operations Text Processing: Variable substitution and text manipulation Getting Started Installation Blackwood.IO is available as a NuGet package: dotnet add package Blackwood.IO Basic Usage File Operations Saving files asynchronously in the background is helpful for scenarios like autosaving, storing user preferences, logging, and similar tasks. using Blackwood; // Background file save (non-blocking) await Util.SaveBackground(stream => { // Write your data to the stream stream.Write(data); }, \"path/to/file.txt\"); // Application information string appName = Application.Name; Caching Caches are used to reduce loading of frequently used remote resources (and even local files). using Blackwood; // Create a cache with capacity limit var cache = new Cache<string, MyData>(maxCapacity: 1000); // Add items to cache cache.Add(\"key1\", myData); // Retrieve items if (cache.TryGet(\"key1\", out MyData data)) { // Use the cached data } Text Processing Variable substitution in strings can be done with: using Blackwood; // Variable substitution var variables = new Dictionary<string, object> { {\"name\", \"John\"}, {\"version\", \"1.0.0\"} }; string result = Text.SubstituteVars(\"Hello {{name}}, version {{version}}!\", variables); // Result: \"Hello John, version 1.0.0!\" Next Steps API Reference - API documentation Contributing - How to contribute to the project Support Documentation: Guides and API reference Issues: Report bugs or request features on GitHub Issues Community: Join discussions and get help from the community"
  },
  "building-docs.html": {
    "href": "building-docs.html",
    "title": "Blackwood.IO Documentation | Blackwood.IO",
    "summary": "Blackwood.IO Documentation This directory contains the documentation project for the Blackwood.IO library. Prerequisites .NET 8.0 SDK or later DocFX (will be installed automatically by the build scripts) Building the Documentation Option 1: Using Visual Studio To build the documentation using Visual Studio: Open the Blackwood.IO.sln solution file in Visual Studio. In the Solution Explorer, locate the Documentation project. Right-click the Documentation project and select Build. Upon successful build, the documentation output will be generated in the ../docs directory. Option 2: Using the Batch Script (Windows) To build and view the documentation locally: Navigate to the Documentation folder Run the build script: .\\build-docs.bat Option 3: Using PowerShell Script (Windows) To build and view the documentation locally: Navigate to the Documentation folder Run the build script: .\\build-docs.ps1 Option 4: Manual Build Install DocFX globally: dotnet tool install -g docfx Generate the documentation: docfx docfx.json Output The generated documentation will be available in the ../docs directory. Open ../docs/index.html in your web browser to view the documentation. When Visual Studio builds the docs, it will also start a local webserver to allow browsing the documents at http://localhost:8080 The documentation, when browsed from a local filesystem, may require tweaking the browser. Firefox Go to about:config and set: security.fileuri.strict_origin_policy to false privacy.file_unique_origin to false Chrome Use a local web server extension like “Web Server for Chrome” or serve the files through a development server. Brave When view the local documentation files with the Brave browser, additional steps are needed. You will have to launch Brave from the command line with specific flags to relax its restrictions. This will not full work, but it allows reading. Open your command prompt or terminal. Launch Brave with the following flags, replacing <path-to-your-index.html> with the full path to your documentation file: macOS: open -n \"/Applications/Brave Browser.app\" --args --user-data-dir=\"$HOME/brave-dev-data\" --disable-web-security \"<path-to-your-index.html>\" Windows: \"C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe\" --user-data-dir=C:\\brave-dev-data --disable-web-security \"<path-to-your-index.html>\" The following flags are important: --allow-file-access-from-files enables local file access for the browser. --disable-web-security disables certain browser security measures (only use this for trusted, local documentation). Make sure to specify the exact path to your documentation index file. Project Structure docfx.json - DocFX configuration file index.md - Main documentation page api/ - API documentation files articles/ - Conceptual documentation template/ - Custom DocFX template files contributing/ - Contributing guidelines Configuration The docfx.json file contains the configuration for: Source code metadata extraction from ../src Content files (markdown, API docs) Output destination (../docs) Template and styling options docfx is fussy, brittle, and its docfx.json documentation is often not helpful for either setting up the project or figuring out why its not working. (Sure there is documentation, but its thin on substance, little on what the actual settings do, or how to accomplish anything.) Updating Documentation Modify the markdown files in this directory Update API documentation by adding XML documentation comments to the source code Run the build script to regenerate the documentation The updated documentation will be available in ../docs"
  },
  "contributing/CONTRIBUTING.html": {
    "href": "contributing/CONTRIBUTING.html",
    "title": "Contributing | Blackwood.IO",
    "summary": "Contributing Thanks for being interested in contributing! We're so glad you want to help! We want contributing to be fun, enjoyable, and educational for all. We love receiving contributions from our community, all contributions are welcome. There are many ways to contribute. You can also help us by: Answering questions people have have in the forums Helping us build and design our website Cleaning up our existing documentation, polishing it, fixing our spelling or grammar mistakes, and so on Create new documentation Create an example of some changes / fixes/ hacks Reviewing submissions Contributing bits that can be incorporated into this or related projects. Below you will find tips on how to get the most out of your contributing experience, including GitHub management tips, setup instructions for docs and code contributions, and more. Not sure how to start contributing? If you are worried or don't know where to start, you can reach out with questions to GitHub Discussions is directly integrated with the repository. You can use this to ask for help or share ideas related to improving the documentation or deploying it. How to start contributing and our code of conduct Below you'll find guides on our community, code of conduct, and how to get started contributing: Code of Conduct: Read about what we expect from everyone participating to make it the most friendly and welcoming community. Style Guide: The art of contributing, a.k.a. the detailed requirements that will make it more likely your contribution is accepted with minimal changes. By participating in this project, you agree to abide by our Code of Conduct. We expect all contributors to follow the Code of Conduct and to treat fellow humans with respect. Important Resources The important documents and links are on the front page of the wiki. Improving Documentation If you have a suggestion for the documentation, we ask that you take a stab at making the changes to the documentation. Simple changes can often be made without a sophisticated pull release. For large fixes, please build and test the documentation before submitting the pull-request to be sure you haven't accidentally introduced any layout or formatting issues. Whitespace Cleanup Don't mix code or documentation changes with whitespace cleanup! If you are fixing whitespace, include those changes separately from your code changes. If your request is unreadable due to whitespace changes, it will be rejected. Please submit whitespace cleanups in a separate pull request. Reorganizing Filesystem / directory tree Don't mix rearranging the location and names of files with code or documentation changes! If you are rearranging the file system, please include those changes separately from your code changes. Please submit file system changes in a separate pull request. Pull Request Process Please see the pull requests page for the process of submitting your changes to the prooject and incorporating feedback. are happy with your changes first! Credits: This page was adapted from an EmbeddedArtistry template"
  },
  "contributing/code_of_conduct.html": {
    "href": "contributing/code_of_conduct.html",
    "title": "Contributor Covenant Code of Conduct | Blackwood.IO",
    "summary": "Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact: A violation through a single incident or series of actions. Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact: A serious violation of community standards, including sustained inappropriate behavior. Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence: A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder. For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations."
  },
  "contributing/how-to-file-an-issue.html": {
    "href": "contributing/how-to-file-an-issue.html",
    "title": "Issues and Bug Tracking | Blackwood.IO",
    "summary": "Issues and Bug Tracking How to File an Issue The GitHub issue tracker is the preferred channel for bug reports, documentation, feature requests and submitting pull requests. To resolve your issue, please select the appropriate category: Bug Reports Documentation Feature Requests For bug reports, include in your issue: The OS version you are running the software on The language (C#, javascript, go, etc) that you are targeting A reproduction for debugging and taking action Please do not use the issue tracker for personal support requests. The discourse and forums are the better places to request help. Labelling the issues Issue labels are a tool in GitHub that are used to group issues into one or more categories. Labeling issues helps by identifying: good issues for new contributors to work on reported and confirmed bugs feature requests duplicate issues issues that are stalled or blocked the status of an open issue the topic or subject matter of the issue When an issue is created – and later examined – this is a good time to check that its label is sensible, and to add an other labels that are helpful – and to remove labels that do not apply. You can see a list of this project's labels (and their descriptions). Tracking and Helping with Issues If an issue is affecting you, start at the top of this list and complete as many tasks on the list as you can: If there is an issue and you can add more detail, write a comment describing how the problem is affecting you, OR if you can, write up a work-around or improvement for the issue If there is not an issue, write the most complete description of what's happening Offer to help fix the issue (and it is totally expected that you ask for help; open-source maintainers want to help contributors) Deliver a well-crafted, tested PR Credits: this was adapted from the Gatsbj.js project"
  },
  "contributing/pull-requests.html": {
    "href": "contributing/pull-requests.html",
    "title": "Pull Requests | Blackwood.IO",
    "summary": "Pull Requests This document describes what you needed to know about the pull request process. A pull request is how you submit your changes to the project. Before you make any changes, please read the contributing page for information regarding contributions to project overall. This will help you in making your changes fit within the project and its style; as well as the steps you must do before creating a pull-request. What is a Pull Request (PR)? As described above, a pull request is how you submit changes to this project. It is a request that the project pull in your changes. Here's how the folks at GitHub define a pull request: Pull requests let you tell others about changes you've pushed to a branch in a repository on GitHub. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. The pull request allows others to review the changes, test them, and provide feedback – including requests to makes to the changees, so that they better fit into the project. Pull Request Process Once you have completed the changes on your local development environment, tested them, and so fprth, the next steps is to create a pull request. Be sure to check the contributing guide for additional steps and tips to ensure that your changes will fit with the project. When you are ready to generate a pull request, either for preliminary review, or for consideration of merging into the project you must first push your local topic branch back up to GitHub: git push origin newfeature Once you've committed and pushed all of your changes to GitHub, go to the page for your fork on GitHub, select your development branch, and click the pull request button. If you need to make any adjustments to your pull request, just push the updates to your branch. Your pull request will automatically track the changes on your development branch and update. Ensure any install or build dependencies are removed before the end of the layer when doing a build. You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you. Review Process After a pull request has been sent to the repository, the team and community may suggest modifications to the changes you have submitted. Many pull requests are likely to open for several days, until the core team can approve them in Github. In some cases, multiple people will have the chance to review/comment. Please check your pull request for comments, feedback, and suggested changes: Review the suggested changes using the “View changes” button. Commit the suggestions. Discuss suggestions to ask questions about the suggested changes. Incoprorate the suggestions to your changes Addressing Feedback Once a PR has been submitted, your changes will be reviewed and constructive feedback may be provided. Feedback isn't meant as an attack, but to help make sure the highest-quality workmanship makes it into our project. Changes will be approved once required feedback has been addressed. If a maintainer asks you to “rebase” your PR, they're saying that a lot of files has changed, and that you need to update your fork so it's easier to merge. To update your forked repository, follow these steps: # Fetch upstream master and merge with your repo's master branch git fetch upstream git checkout master git merge upstream/master # If there were any new commits, rebase your development branch git checkout newfeature git rebase master If too much code has changed for git to automatically apply your branches changes to the new master, you will need to manually resolve the merge conflicts yourself. Once your new branch has no conflicts and works correctly, you can override your old branch using this command: git push -f Note that this will overwrite the old branch on the server, so make sure you are happy with your changes first! Additional resources Creating a pull request from GitHub Configuring a remote for a fork Which remote URL should I use? Git Branching and Merging Feature Branching and Workflows Resolving merge conflicts Credits: This page was adapted from an EmbeddedArtistry template and adapted from the Gatsbj.js project"
  },
  "contributing/style-guide.html": {
    "href": "contributing/style-guide.html",
    "title": "Style Guide | Blackwood.IO",
    "summary": "Style Guide The .proto files should follow Google's protobuf style guidelines. Documentation style Markdown files The title of the document should use a # (in Markdown). Only a single title (#) should be used. The heading levels should start with ## (in Markdown) and grow in order Links ought to be relative instead of absolute when linking to documents. That is to say, the should not include the full domain. For example /documents/some-reference/ instead of https://randym32.github.io/Blackwood.IO/some-reference/"
  },
  "glossary.html": {
    "href": "glossary.html",
    "title": "Glossary | Blackwood.IO",
    "summary": "Glossary This glossary defines terms and concepts used in the library documentation. A Application Name : The name of the current application, typically derived from the entry assembly name. Used by the Application.Name property to identify the running application. B Background Save : A file saving mechanism that prevents UI blocking. Implemented by the Util.SaveBackground method. C Cache : An in-memory storage mechanism that provides fast access to frequently used data. The Blackwood.IO cache uses a LRU (Least Recently Used) eviction policy. Cache Item : A single entry in the cache containing a key-value pair with metadata for tracking access order and expiration. Cache Key : The unique identifier used to store and retrieve items from the cache. Cache Value : The actual data stored in the cache associated with a specific key. D Doubly-Linked List : A data structure where each node contains references to both the next and previous nodes. Used in the cache implementation to maintain access order for LRU eviction. E Embedded Resources : Files that are compiled into the assembly and can be accessed at runtime without requiring separate file deployment. Entry Assembly : The assembly that contains the application's entry point (typically the Main method). Used to find resources associated with the application, and determine the application name, . F File Stream : A stream that provides read/write access to a file on disk. Folder Wrapper : An abstraction layer that provides a consistent interface for folder operations across different storage systems. H Hash Table : A data structure that provides fast key-value lookups using hash codes. Used internally by the cache for O(1) access time. L LRU (Least Recently Used) : A cache eviction policy that removes the least recently accessed items when the cache reaches its capacity limit. M Memory Cache : An in-memory storage system that keeps frequently accessed data in RAM for fast retrieval. P Path Operations : Utility functions for working with file and directory paths, including path resolution and manipulation. R Race Condition : A situation where multiple threads access shared resources simultaneously, potentially causing unpredictable behavior. Prevented using locks in background save operations. S Stack Trace : A representation of the call stack at a particular point in time, used as a fallback method to determine the application assembly. Substitute Variables : A text processing feature that replaces placeholder variables (in the format {{variableName}}) with actual values from a provided dictionary. T Tableau : A dictionary or collection of key-value pairs used for variable substitution in text processing. Temporary File : A file created during background save operations to ensure atomic writes and prevent data corruption. Thread-Safe : Code that can be safely executed by multiple threads simultaneously without causing race conditions or data corruption. V Variable Substitution : The process of replacing placeholder variables in text with actual values from a provided data source. W Write Background : A delegate type that defines the signature for background file writing operations. Z Zip Wrapper : An abstraction layer that provides a consistent interface for ZIP file operations."
  },
  "index.html": {
    "href": "index.html",
    "title": "Blackwood.IO Documentation | Blackwood.IO",
    "summary": "Blackwood.IO Documentation Welcome to the documentation for Blackwood.IO a .NET library that provides utilities for file operations, caching, and more. Overview Blackwood.IO is a set of high-level utilities for performing file and directory operations, caching, and abstracting common IO patterns. It simplifies several file-system tasks. Getting Started Prerequisites .NET 8.0 or later Visual Studio 2022 or later (Windows), or VS Code with C# extension (cross-platform) Installation Install the package via NuGet: dotnet add package Blackwood.IO Or using Package Manager Console: Install-Package Blackwood.IO Resources Source Code: GitHub Repository NuGet Package: Blackwood.IO Documentation: API Reference Documentation The API documentation is available at https://randym32.github.io/Blackwood.IO. For instructions on how to build or modify the documentation, see How to Build the Documentation. This documentation covers the API reference and usage examples for Blackwood.IO. Glossary For definitions of key terms and concepts used throughout this documentation, see the Glossary. Contributing We welcome contributions! Please see our Contributing Guidelines for information on how to contribute to this project. Issues: Report bugs or request features on GitHub Issues Pull Requests: Submit improvements via GitHub Pull Requests Code of Conduct: Please read our Code of Conduct License This project is licensed under the BSD 2-Clause License – see the LICENSE file for details."
  }
}